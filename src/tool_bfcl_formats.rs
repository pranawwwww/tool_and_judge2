use std::collections::HashMap;

use indexmap::IndexMap;
use serde::{Deserialize, Serialize};
use serde_json::json;

use crate::one_entry_map::KeyValuePair;

#[derive(Serialize, Deserialize, Clone)]
pub struct BfclRoleContentPair {
    pub role: String,
    pub content: String,
}

/// This struct models a single entry in the BFCL dataset.
/// 
/// For the question field, it is represented as a list of list of role-content pairs,
/// where each outer list element represents a turn in the conversation,
/// and each inner list element represents a message with a specific role and content.
/// 
/// For the function field, it is represented as a list of function definitions.
#[derive(Serialize, Deserialize, Clone)]
pub struct BfclDatasetEntry {
    pub id: String,
    pub question: Vec<Vec<BfclRoleContentPair>>,
    pub function: Vec<BfclFunctionDef>,
    // pub raw_entry: serde_json::Value,
}

impl BfclDatasetEntry {
    
    // pub fn modify_question_content(&mut self, new_content: &str) -> Result<(), String> {
    //     let raw_entry = &mut self.raw_entry;
    //     let question_array = raw_entry
    //         .get_mut("question")
    //         .and_then(|v| v.as_array_mut())
    //         .ok_or("Missing or invalid 'question' field")?;
    //     let first_question = question_array
    //         .get_mut(0)
    //         .and_then(|v| v.as_array_mut())
    //         .ok_or("Missing or invalid 'question[0]' field")?;
    //     let first_content = first_question
    //         .get_mut(0)
    //         .and_then(|v| v.as_object_mut())
    //         .ok_or("Missing or invalid 'question[0][0]' field")?;
    //     first_content.insert(
    //         "content".to_string(),
    //         serde_json::Value::String(new_content.to_string()),
    //     );
    //     self.question_content = new_content.to_string();
    //     Ok(())
    // }
}

#[derive(Serialize, Deserialize, Clone)]
pub struct BfclFunctionDef {
    pub name: String,
    pub description: String,
    pub parameters: BfclParameter,
}

/// This is the derivation of the structure model for BFCL's single parameter (by observing the dataset).
///
/// It may recursively appear in the value of "properties" or "items" field.
///
/// Fields annotated with `skip_serializing_if` are all technically optional, although semantically some of them always appear under certain conditions.
///
/// BFCL does not have specification on the concrete syntax rules, so we cannot assume anything regarding the field appearance patterns.
///
/// This model assumes that the conventional "list of arguments" can be represented with a single parameter of this type on the top level.
///
/// In all BFCL dataset entries, it seems that the top level parameter has a significant difference from its nested parameters:
///
/// - The top level parameter always has "type": "dict", and always has a "properties" field.
///
/// It may be reasonable to model the top level parameter separately, but it might be against BFCL's intended semantic.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BfclParameter {
    #[serde(rename = "type")]
    pub ty: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<IndexMap<String, BfclParameter>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub items: Option<Box<BfclParameter>>,
    #[serde(rename="enum", skip_serializing_if = "Option::is_none")]
    pub r#enum: Option<Vec<serde_json::Value>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub format: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub required: Option<Vec<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub default: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub optional: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub maximum: Option<serde_json::Value>,
}
/// This struct models the function call in the ground truth data of BFCL dataset.
///
/// In BFCL, the function call is represented by a single key value pair where
/// the key is the function name and the value is a map from parameter names to their arguments.
///
/// For ground truth function calls, each parameter maps to a list of possible argument values (to allow for multiple correct answers).
#[derive(Serialize, Deserialize, Clone)]
pub struct BfclGroundTruthFunctionCall(
    pub KeyValuePair<String, IndexMap<String, Vec<serde_json::Value>>>,
);
/// This struct models the function call output generated by the model in BFCL.
///
/// In BFCL, the function call is represented by a single key value pair where
/// the key is the function name and the value is a map from parameter names to their arguments.
///
/// For output function calls, each parameter maps to a single argument value.
#[derive(Serialize, Deserialize, Clone)]
pub struct BfclOutputFunctionCall(pub KeyValuePair<String, IndexMap<String, serde_json::Value>>);

#[derive(Serialize, Deserialize, Clone)]
pub struct BfclGroundTruthEntry {
    pub id: String,
    pub ground_truth: Vec<BfclGroundTruthFunctionCall>,
}

// impl BfclGroundTruthEntry {
//     pub fn deserialize_from_json(raw_entry: serde_json::Value) -> Result<Self, String> {
//         let id = raw_entry
//             .get("id")
//             .and_then(|v| v.as_str())
//             .ok_or("Missing or invalid 'id' field")?
//             .to_string();

//         let gt_array = raw_entry
//             .get("ground_truth")
//             .and_then(|v| v.as_array())
//             .ok_or("Missing or invalid 'ground_truth' field")?;

//         let mut ground_truth = Vec::new();
//         for gt_val in gt_array {
//             let function_call = BfclGroundTruthFunctionCall::deserialize_from_json(gt_val)?;
//             ground_truth.push(function_call);
//         }

//         Ok(BfclGroundTruthEntry { id, ground_truth })
//     }
// }
// sample ground truth function call:
// {"triangle_properties.get": {"side1": [5], "side2": [4], "side3": [3], "get_area": ["", true], "get_perimeter": ["", true], "get_angles": ["", true]}}
