use codebase_rs::{
    models::{function_name_mapper::FunctionNameMapper, gpt5_interface::Gpt5Interface},
    tool_bfcl_formats::BfclDatasetEntry,
};
use std::fs::{File, OpenOptions};
use std::io::{BufRead, BufReader, Write};

/// Test to compare tool formats generated by Rust implementation
///
/// This test reads the BFCL_v4_multiple.jsonl dataset and generates
/// tool definitions using the Rust implementation, then writes them
/// to a file for comparison with the Python implementation.
#[test]
fn test_rust_tool_format_generation() {
    let dataset_path = "tool/dataset/BFCL_v4_multiple.jsonl";
    let output_path = "tool_format_comparison_rust.json";

    // Read the dataset
    let file = File::open(dataset_path)
        .expect(&format!("Failed to open dataset file: {}", dataset_path));
    let reader = BufReader::new(file);

    // Create output file
    let mut output_file = OpenOptions::new()
        .create(true)
        .write(true)
        .truncate(true)
        .open(output_path)
        .expect("Failed to create output file");

    let mut results = Vec::new();

    for (line_num, line_result) in reader.lines().enumerate() {
        let line = line_result.expect("Failed to read line");

        if line.trim().is_empty() {
            continue;
        }

        // Parse the JSON line
        let raw_entry: serde_json::Value = serde_json::from_str(&line)
            .expect(&format!("Failed to parse JSON at line {}", line_num + 1));

        // Deserialize to BfclDatasetEntry
        // let dataset_entry = BfclDatasetEntry::deserialize_from_json(raw_entry.clone())
        //     .expect(&format!("Failed to deserialize entry at line {}", line_num + 1));
        let dataset_entry: BfclDatasetEntry = serde_json::from_value(raw_entry)
            .expect(&format!("Failed to deserialize entry at line {}", line_num + 1));

        // Create a function name mapper for this entry
        let mut name_mapper = FunctionNameMapper::new();

        // Generate GPT-5 tools using the Rust implementation
        let gpt5_tools = Gpt5Interface::sanitize_and_convert_function_format(
            &dataset_entry.function,
            &mut name_mapper,
        );

        // Serialize to JSON
        let tools_json = serde_json::to_value(&gpt5_tools)
            .expect("Failed to serialize tools to JSON");

        // Create result object with id and tools
        let result = serde_json::json!({
            "id": dataset_entry.id,
            "question": dataset_entry.question[0][0].content,
            "tools": tools_json,
            "name_mappings": {
                "original_to_sanitized": name_mapper.original_to_sanitized,
                "sanitized_to_original": name_mapper.sanitized_to_original,
            }
        });

        results.push(result);
    }

    // Write all results to the output file as a JSON array
    let output_json = serde_json::to_string_pretty(&results)
        .expect("Failed to serialize results to JSON");

    writeln!(output_file, "{}", output_json)
        .expect("Failed to write to output file");

    println!("Rust tool format generation completed. Output written to: {}", output_path);
    println!("Total entries processed: {}", results.len());
}
